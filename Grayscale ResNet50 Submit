import torch.nn as nn
import torchvision.transforms as transforms
from torchvision import models
from torch.utils.data import Dataset, DataLoader
import pandas as pd
import cv2
from PIL import Image
import os
from tqdm import tqdm
# Set device
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f"Using device: {device}")
class DRClassifier(nn.Module):
    def **init**(self, num_classes=5):
        super(DRClassifier, self).**init**()
       
        # Initialize ResNet50 WITHOUT pretrained weights (we'll load from your saved model)
        self.backbone = models.resnet50(pretrained=False)
       
        # Modify final layer for classification
        num_features = self.backbone.fc.in_features
        self.backbone.fc = nn.Linear(num_features, num_classes)
        self.dropout = nn.Dropout(0.5)
       
    def forward(self, x):
        x = self.backbone.conv1(x)
        x = self.backbone.bn1(x)
        x = self.backbone.relu(x)
        x = self.backbone.maxpool(x)
       
        x = self.backbone.layer1(x)
        x = self.backbone.layer2(x)
        x = self.backbone.layer3(x)
        x = self.backbone.layer4(x)
       
        x = self.backbone.avgpool(x)
        x = torch.flatten(x, 1)
        x = self.dropout(x)
        x = self.backbone.fc(x)
        return x
class TestDataset(Dataset):
    def **init**(self, csv_file, img_dir, transform=None):
        self.data = pd.read_csv(csv_file)
        self.img_dir = img_dir
        self.transform = transform
       
    def **len**(self):
        return len<a href="http://self.data" target="_blank" rel="noopener noreferrer nofollow"></a>
   
    def **getitem**(self, idx):
        img_name = self.data.iloc[idx, 0]
       
        # Try different extensions
        for ext in ['.png', '.jpg', '.jpeg']:
            img_path = os.path.join(self.img_dir, f"{img_name}{ext}")
            if os.path.exists(img_path):
                break
       
        # Load and convert to grayscale
        image = cv2.imread(img_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        grayscale = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        grayscale_3ch = cv2.cvtColor(grayscale, cv2.COLOR_GRAY2RGB)
        image = Image.fromarray(grayscale_3ch)
       
        if self.transform:
            image = self.transform(image)
           
        return image, img_name
# Load the trained model
print("Loading trained model...")
model = DRClassifier(num_classes=5) # Initialize with pretrained=False
# Load your complete trained weights (this contains everything!)
model.load_state_dict(torch.load('/kaggle/input/diabetic-retinopathy-grayscale-model-experiment/best_grayscale_model.pth',
                                map_location=device))
model.to(device)
model.eval()
print("Model loaded successfully!")
# Test transforms
test_transforms = transforms.Compose([
    transforms.Resize((512, 512)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])
# Load test dataset
print("Loading test dataset...")
test_dataset = TestDataset(
    csv_file='/kaggle/input/aptos2019-blindness-detection/test.csv',
    img_dir='/kaggle/input/aptos2019-blindness-detection/test_images',
    transform=test_transforms
)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False, num_workers=4)
print(f"Test dataset loaded: {len(test_dataset)} images")
# Generate predictions
print("Generating predictions...")
predictions = []
image_names = []
with torch.no_grad():
    for data, names in tqdm(test_loader, desc="Predicting"):
        data = data.to(device)
        outputs = model(data)
        preds = outputs.argmax(dim=1)
       
        predictions.extend(preds.cpu().numpy())
        image_names.extend(names)
# Create submission file
submission = pd.DataFrame({
    'id_code': image_names,
    'diagnosis': predictions
})
submission.to_csv('submission.csv', index=False)
print(f"Submission file created: submission.csv")
print(f"Total predictions: {len(predictions)}")
print("\nPrediction distribution:")
print(submission['diagnosis'].value_counts().sort_index())
print("\nFirst 5 predictions:")
print(submission.head())
